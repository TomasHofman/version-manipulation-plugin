package org.jboss.set.gradle4.versionmanipulation;

import java.io.File;

import org.gradle.api.Action;
import org.gradle.api.NamedDomainObjectSet;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.artifacts.maven.MavenResolver;
import org.gradle.api.internal.project.ProjectInternal;
import org.gradle.api.java.archives.internal.DefaultManifest;
import org.gradle.api.plugins.osgi.OsgiManifest;
import org.gradle.api.publish.PublishingExtension;
import org.gradle.api.publish.maven.MavenPublication;
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin;
import org.gradle.api.tasks.Upload;
import org.gradle.api.tasks.bundling.Jar;
import org.jboss.set.gradle4.versionmanipulation.configuration.ConfigurationStore;
import org.jboss.set.gradle4.versionmanipulation.configuration.PropertiesConfigurationStore;
import org.jboss.set.gradle4.versionmanipulation.internal.DependencyResolutionApplier;
import org.jboss.set.gradle4.versionmanipulation.internal.PomTransformer;

public class VersionManipulationPlugin implements Plugin<ProjectInternal> {

    private static final String CONFIG_FILE_NAME = "overrideVersions.properties";

    private ConfigurationStore configurationStore;

    @Override
    public void apply(ProjectInternal project) {
        PluginLogger.ROOT_LOGGER.infof("Applying VersionManipulationPlugin to project %s", project.getName());

        configurationStore = new PropertiesConfigurationStore(new File(project.getRootProject().getRootDir(), CONFIG_FILE_NAME));

        overrideProjectVersion(project);
        project.getConfigurations().all(new DependencyResolutionApplier(project, configurationStore));
        configureUploadTasks(project);
        configurePublications(project);
        configureOsgiManifest(project);

    }

    /**
     * Overrides project version.
     */
    private void overrideProjectVersion(Project project) {
        project.afterEvaluate(new Action<Project>() {
            @Override
            public void execute(Project project) {
                project.setVersion(configurationStore.getProjectVersion());
            }
        });
    }

    /**
     * Transforms POM files generated by maven plugin.
     */
    private void configureUploadTasks(Project project) {
        project.getTasks().withType(Upload.class).all(new Action<Upload>() {
            @Override
            public void execute(Upload upload) {
                upload.getRepositories().withType(MavenResolver.class).all(new Action<MavenResolver>() {
                    @Override
                    public void execute(MavenResolver resolver) {
                        resolver.getPom().withXml(new PomTransformer(configurationStore));
                    }
                });
            }
        });
    }

    /**
     * Transforms POM files generated by maven-publish plugin.
     */
    private void configurePublications(Project project) {
        project.getPlugins().withType(MavenPublishPlugin.class, new Action<MavenPublishPlugin>() {
            @Override
            public void execute(MavenPublishPlugin mavenPublishPlugin) {
                project.getExtensions().configure(PublishingExtension.class, new Action<PublishingExtension>() {
                    @Override
                    public void execute(PublishingExtension publishingExtension) {
                        NamedDomainObjectSet<MavenPublication> mavenPublications =
                                publishingExtension.getPublications().withType(MavenPublication.class);
                        mavenPublications.all(new Action<MavenPublication>() {
                            @Override
                            public void execute(MavenPublication mavenPublication) {
                                if (mavenPublication.getPom() != null) {
                                    mavenPublication.getPom().withXml(new PomTransformer(configurationStore));
                                }
                            }
                        });
                    }
                });
            }
        });
    }

    /**
     * Overrides version entries in manifest file.
     */
    private void configureOsgiManifest(Project project) {
        // TODO: Is this too project specific?
        project.afterEvaluate(new Action<Project>() {
            @Override
            public void execute(Project project) {
                project.getTasks().withType(Jar.class, new Action<Jar>() {
                    @Override
                    public void execute(Jar jar) {
                        if (jar.getManifest() instanceof OsgiManifest) {
                            PluginLogger.ROOT_LOGGER.debugf("Overriding OsgiManifest");
                            OsgiManifest manifest = (OsgiManifest) jar.getManifest();
                            if (manifest.getInstructions().containsKey("Implementation-Version")) {
                                manifest.instructionReplace("Implementation-Version", configurationStore.getProjectVersion());
                            }
                            if (manifest.getInstructions().containsKey("Specification-Version")) {
                                manifest.instructionReplace("Specification-Version", configurationStore.getProjectVersion());
                            }
                        } else if (jar.getManifest() instanceof DefaultManifest) {
                            PluginLogger.ROOT_LOGGER.debugf("Overriding DefaultManifest");
                            // TODO what are common entries here?
                        }
                    }
                });
            }
        });
    }
}
